<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,user-scalable=0" />
		<title>Události a asynchronní zpracování</title>
	<body>

<h1>Události a asynchronní zpracování</h1>

<section class="slide">
	<h2>Události a asynchronní zpracování</h2>
	<ul>
		<li>Webová interaktivní prezentace</li>
		<li>"?" zobrazí krátkou nápovědu</li>
		<li>Tisk jako obvykle</li>
		<li>Pro pokračování stiskněte mezerník</li>
	</ul>
</section>

<section class="slide">
	<h2>Obsah</h2>
	<ol>
		<li>Události: opáčko</li>
		<li>Události: objekt události</li>
		<li>Události: capture a bubble</li>
		<li>Události: posluchače</li>
		<li>Asynchronní zpracování</li>
		<li>Promises a dále</li>
	</ol>
</section>

<section class="slide">
	<h2>Události: opáčko</h2>
	<ul>
		<li>Alternativní způsob řízení toku programu</li>
		<li><em>Event-based programming</em></li>
		<li><code>Až nastane X, udělej Y</code></li>
	</ul>
</section>

<section class="slide">
	<h2>Události: opáčko</h2>
	<code class="block" data-syntax="js">var func = function(e) {
	alert("...");
}
document.body.addEventListener("click", func, false);
</code>
</section>

<section class="slide">
	<h2>Události: opáčko</h2>
	<p>Co je na událostech zajimavého?</p>
	<ul>
		<li>Na jakých vznikají prvcích?</li>
		<li>Jaké existují?</li>
		<li>Co obsahuje (jediný) parametr posluchače?</li>
		<li>Jaký význam má třetí parametr <code>addEventListener</code>?</li>
	</ul>
</section>

<section class="slide">
	<h2>Události: objekt události</h2>
	<ul>
		<li>Liší se podle typu události</li>
		<li>Vždy obsahuje <code>target</code>, <code>currentTarget</code>, <code>timeStamp</code>, <code>type</code></li>
		<li>Vždy obsahuje <code>stopPropagation</code> a <code>preventDefault</code></li>
	</ul>
</section>

<section class="slide">
	<h2>Události klávesnice</h2>
	<ul>
		<li><code>keydown</code>, <code>keypress</code>, <code>keyup</code></li>
		<li>Modifikátory <code>ctrlKey</code>, <code>altKey</code>, <code>shiftKey</code>, <code>metaKey</code></li>
		<li>Stisk a uvolnění obsahuje <code>keyCode</code>
			<ul>
				<li>Identifikátor klávesy na klávesnici (int)</li>
				<li>Seznam na <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode">https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode</a></li>
			</ul>
		</li>
		<li>Tištitelný keypress obsahuje <code>charCode</code>
			<ul>
				<li>Unicode code point znaku (int)</li>
				<li><code>String.fromCharCode</code> převede na znak</li>
			</ul>
		</li>
	</ul>
</section>

<section class="slide">
	<h2>Události klávesnice</h2>
	<ul>
		<li>Dělení na keydown/keypress se ukázalo jako nepraktické</li>
		<li>Dělení na tištitelné/netištitelné se ukázalo jako nepraktické</li>
		<li>Aktuálně probíhá implementace upraveného API, ve kterém je jen keydown/keyup</li>
		<li>Vlastnost <code>key</code>
			<ul>
				<li>Identifikátor stisklé logické klávesy (string)</li>
				<li>Seznam na <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values</a></li>
			</ul>
		</li>
		<li>Vlastnost <code>code</code>
			<ul>
				<li>Identifikátor stisklé fyzické (hardwarové) klávesy</li>
				<li>Stejná množina hodnot jako u <code>key</code></li>
			</ul>
		</li>
	</ul>
</section>

<section class="slide">
	<h2>Události myši</h2>
	<ul>
		<li><code>mousedown</code>, <code>mouseup</code>, <code>click</code>, <code>mouseover</code>, <code>mouseout</code>, <code>mousemove</code></li>
		<li><code>clientX</code> a <code>clientY</code> &ndash; souřadnice kurzoru vůči průhledu</li>
		<li><code>button</code> je tlačítko (0 = levé, 1 = prostřední, 2 = pravé)</li>
	</ul>
</section>

<section class="slide">
	<h2>Události dotykové</h2>
	<ul>
		<li><code>touchstart</code>, <code>touchmove</code>, <code>touchend</code>, (<code>gesturechange</code>)</li>
		<li><code>touches</code> &ndash; pole všech dotyků</li>
		<li><code>changedTouches</code> &ndash; pole změněných dotyků</li>
		<li><code>targetTouches</code> &ndash; pole dotyků na cílovém prvku</li>
		<li>Dotyk je mini-událost, obsahující pozici a doplňkové údaje (sílu stisku, velikost prstu a natočení)</li>
	</ul>
</section>

<section class="slide">
	<h2>Události ostatní</h2>
	<ul>
		<li><code>focus</code>, <code>blur</code></li>
		<li><code>input</code>, <code>change</code>, <code>submit</code></li>
		<li><code>scroll</code>, <code>resize</code></li>
		<li><code>DOMContentLoaded</code></li>
		<li><a href="https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference">Kompletní soupis</a></li>
	</ul>
</section>

<section class="slide">
	<h2>Capture a bubble #1</h2>
	<ul>
		<li>Třetí parametr pro <code>addEventListener</code> je <em>useCapture</em></li>
		<li>Posluchače události jsou volány nejprve ve fázi capture, poté ve fázi bubble</li>
		<li>Pořadí fází a volání viz <a href="img/event.gif">diagram</a></li>
	</ul>
</section>

<section class="slide">
	<h2>Capture a bubble #2</h2>
	<ul>
		<li>Více posluchačů na stejném uzlu (ve stejné fázi) je voláno v definovaném pořadí</li>
		<li>Zpracovávání události (mezi uzly) lze zastavit voláním <code>stopPropagation()</code></li>
		<li>Zpracovávání události (v rámci uzlu) lze zastavit voláním <code>stopImmediatePropagation()</code></li>
		<li>Metoda <code>preventDefault()</code> s tím nijak nesouvisí</li>
	</ul>
</section>

<section class="slide">
	<h2>Capture a bubble #3</h2>
	<ul>
		<li>Některé události nebublají&hellip;</li>
		<li>&hellip;ale i tyto procházejí capture</li>
		<li><code>load</code>, <code>unload</code></li>
		<li><code>focus</code>, <code>blur</code></li>
	</ul>
</section>

<section class="slide">
	<h2>Posluchače událostí</h2>
	<p>Varianta 1: posluchač je funkce</p>
	<code class="block" data-syntax="js">window.addEventListener("load", function(e) {
	alert(e.target == this);
});</code>
	<ul>
		<li><code>this</code> je prvek, na kterém je posluchač zavěšen (nikoliv ten, kde událost vznikla)</li>
		<li>Pokud chceme předat parametry nebo změnit this, použijeme <code>bind</code></li>
	</ul>
</section>

<section class="slide">
	<p style="text-align: center"><img src="img/secret.jpg" /></p>
</section>

<section class="slide">
	<h2>Posluchače událostí</h2>
	<p>Varianta 2: posluchač je objekt</p>
	<code class="block" data-syntax="js">var obj = {
	handleEvent: function(e) {
		alert(this == obj);
	}
}
window.addEventListener("load", obj);</code>
	<ul>
		<li><code>obj</code> musí mít metodu <code>handleEvent</code></li>
		<li><code>this</code> je posluchač</li>
	</ul>
</section>

<section class="slide">
	<h2>Asynchronní zpracování</h2>
	<ul>
		<li>JavaScript je vykonáván v jednom vlákně</li>
		<li>Není nutné řešit přerušení a synchronizaci vykonávání</li>
		<li><em>Event loop</em></li>
	</ul>
</section>

<section class="slide">
	<h2>Event loop</h2>
	<code class="block" data-syntax="js">var scheduledJS = "";
var listeners = [];

while (1) {
	eval(scheduledJS); /* TADY se vykoná JS */

	if (!listeners.length) break;

	/* počkat, než bude čas na nejbližší posluchač */
	var currentListener = waitFor(listeners);

	/* naplánovat jej */
	scheduledJS = listeners[currentListener];
	delete listeners[currentListener];
}</code>
</section>

<section class="slide">
	<h2>Zpožděné vykonávání</h2>
	<ul>
		<li>Je řada způsobů, jak "naplánovat" zpožděné vykonání kódu</li>
		<li>XMLHttpRequest, addEventListener</li>
		<li><code class="block" data-syntax="js">setTimeout(  function() { /* ... */ }, 1000);
setInterval( function() { /* ... */ }, 100);
</code></li>
		<li>Pořadí určuje <del>lékař</del> prohlížeč, ale vždy nejprve v příští iteraci event loopu</li>
	</ul>
</section>

<section class="slide">
	<h2>Zpožděné vykonávání: this v callbacku</h2>
	<ul>
		<li>Pokud někam předávám funkci, s jakým <code>this</code> bude volána?</li>
		<li><code class="block" data-syntax="js">var Animal = function() {
	setTimeout(this.eat, 3000);
}

Animal.prototype.eat = function() {
	this.food += 3;
}
</code></li>
	</ul>
</section>

<section class="slide">
	<h2>Zpožděné vykonávání: this v callbacku</h2>
	<ul>
		<li><code>bind</code> pomůže</li>
		<li><code class="block" data-syntax="js">var Animal = function() {
	setTimeout(this.eat.bind(this), 3000);
}

Animal.prototype.eat = function() {
	this.food += 3;
}
</code></li>
	</ul>
</section>

<section class="slide">
	<h2>Zpožděné vykonávání: requestAnimationFrame</h2>
	<ul>
		<li><code>setTimeout</code> zní jako rozumné řešení pro JS animace</li>
		<li><code>requestAnimationFrame</code> je výrazně vhodnější alternativa</li>
		<li><code class="block" data-syntax="js">requestAnimationFrame(function() {
	/* animujeme... */
});
</code></li>
		<li>Prohlížeč sám volí vhodnou délku časového kroku (zpravidla okolo 60 fps)</li>
		<li>Více info viz <a href="https://developer.mozilla.org/en-US/docs/DOM/window.requestAnimationFrame">MDN</a></li>
	</ul>
</section>

<section class="slide">
	<h2>Promises</h2>
	<ul>
		<li>Při návrhu vlastního API narážíme na asynchronní funkce</li>
		<li>Takové funkce vyžadují <code>callback</code></li>
		<li>Kolikátý parametr? Co návratová hodnota? Co výjimky?</li>
		<li>Co podmíněně asynchronní funkce?</li>
	</ul>
</section>

<section class="slide">
	<h2>Promises</h2>
	<ul>
		<li>Návrhový vzor <code>Promise</code> nabízí výrazně přehlednější řízení asynchronního kódu</li>
		<li>Promise je <em>krabička na časem získanou hodnotu</em></li>
		<li>(podmíněně) asynchronní funkce <strong>vrací</strong> Promise</li>
		<li>Zájemce může na promise navěsit posluchače (dva různé)</li>
	</ul>
</section>

<section class="slide">
	<h2>Promises: ukázka</h2>
	<code class="block" data-syntax="js">var getData = function() {
	var promise = new Promise();
	/* ... */
	return promise;
}

getData().then(
	function(data) { alert(data); },
	function(error) { alert(error); }
);
</code>
</section>

<section class="slide">
	<h2>Promises: doplnění</h2>
	<ul>
		<li>Promise se může nacházet ve stavech "pending", "fulfilled", "rejected"</li>
		<li>Fulfilled/rejected == "resolved"</li>
		<li>Tvůrce promise ji mění, konzument jen poslouchá (<code>then</code>)</li>
		<li>Vyrobit lze již naplněnou promise: <code>Promise.resolve(123)</code></li>
		<li>Volání <code>then()</code> vrací novou promise (‽) &rArr; řetězení</li>
		<li>Některé prohlížeče Promise nabízejí, pro jiné existují knihovny</li>
	</ul>
</section>

<section class="slide">
	<h2>Promises: další API</h2>
	<code class="block" data-syntax="js">getData().catch(console.error); // jako .then(null, console.error)

var p1 = getData();
var p2 = getData();

Promise.all([p1, p2]).then( ... );  // parametr callbacku je pole hodnot
Promise.race([p1, p2]).then( ... ); // první s hodnotou
</code>
</section>

<section class="slide">
	<h2>Promises: tvorba a změna stavu</h2>
	<ul>
		<li>Je to složité!</li>
		<li>&hellip;protože měnit stav smí jen producent</li>
		<li>Tedy nic jako <code>Promise.prototype.fulfill = ...</code></li>
		<li>API konstruktoru <code>new Promise</code> vyžaduje funkci (tzv. exekutor), které budou <em>řídící nástroje</em> předány</li>
	</ul>
</section>

<section class="slide">
	<h2>Promises: tvorba a změna stavu</h2>
	<code class="block" data-syntax="js">var promise = new Promise(function(resolve, reject) {
	/* funkce dodaná tvůrcem Promise */
	if (...) {
		resolve(value);
	} else {
		reject(error);
	}
});
return promise;
</code>
</section>

<section class="slide">
	<h2>Promises v praxi</h2>
	<ul>
		<li>Nacházíme se v období přechodu z callbacků na Promises</li>
		<li>Stará API (<code>setTimeout</code>) požadují callbacky, nová (<code>fetch</code>) vrací Promise</li>
		<li>Nový kód by měl vždy pracovat s Promises</li>
	</ul>
</section>

<section class="slide">
	<h2>Žhavá novinka: async/await</h2>
	<ul>
		<li>Novinka z ES2017</li>
		<li>Nadstavba nad Promises</li>
		<li>Asynchronní funkce stále vracejí Promise</li>
		<li>Konzument může na hodnotu čekat blokujícím způsobem</li>
		<li><a href="http://ondras.zarovi.cz/slides/2018/async-await/">Přednáška o async/await</a></li>
	</ul>
</section>

<section class="slide">
	<h2>Žhavá novinka: async/await</h2>
	<code class="block" data-syntax="js">async function getData() {
	try {
		let data = await fetch(...); // vrací Promise
		let processed = process(data);
		return processed;            // implicitně obaleno do Promise
	} catch (e) {
		// Promise rejection
	}
}</code>
</section>

<section class="slide">
	<h2>Prostor pro otázky</h2>
</section>

<footer>
	<a href="http://twitter.com/0ndras">twitter.com/0ndras</a>
	<a href="mailto:ondrej.zara@firma.seznam.cz">ondrej.zara@firma.seznam.cz</a>
</footer>

<script src="../../jsslides/v3/slides/slides3.js"></script>
<script>
	Slides.modules.skin = "cvut";
	Slides.modules.numbering = false;
</script>

</body>
</html>
